/**
 * This class provides JavaSE-17 syntax with a style of context-free grammers. Look chapter 19 of the specification.
 * JavaSE 17 specification
 * https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf
 * 
 * @author me
 */


//Productions from section 3(Lexical Structure):
branch(IDENTIFIER)
T.IDENTIFIER,
T.EXPORTS,
T.MODULE,
// T.NON_SEALED,
T.OPEN,
T.OPENS,
T.PERMITS,
T.PROVIDES,
T.RECORD,
T.REQUIRES,
T.SEALED,
T.TO,
T.TRANSITIVE,
T.USES,
T.VAR,
T.WITH,
T.YIELD

/* I excluded this production because it is obviously inappropriate. */ 
//accept(N.IDENTIFIER, T.NON_SEALED)


branch(TYPE_IDENTIFIER)
T.IDENTIFIER,
T.EXPORTS,
T.MODULE,
// T.NON_SEALED,
T.OPEN,
T.OPENS,
T.PROVIDES,
T.REQUIRES,
T.TO,
T.TRANSITIVE,
T.USES,
T.WITH

branch(UNQUALIFIED_METHOD_IDENTIFIER)
T.IDENTIFIER,
T.EXPORTS,
T.MODULE,
// T.NON_SEALED,
T.OPEN,
T.OPENS,
T.PERMITS,
T.PROVIDES,
T.RECORD,
T.REQUIRES,
T.SEALED,
T.TO,
T.TRANSITIVE,
T.USES,
T.VAR,
T.WITH

branch(LITERAL)
T.INTEGER_LITERAL,
T.FLOATING_POINT_LITERAL,
BOOLEAN_LITERAL,
CHARACTER_LITERAL,
T.STRING_LITERAL,
T.TEXT_BLOCK,
NULL_LITERAL

branch(BOOLEAN_LITERAL)
T.TRUE,
T.FALSE

accept(NULL_LITERAL, T.NULL)

//Productions from section 4(Types, Values, and Variables):
branch(TYPE)
PRIMITIVE_TYPE,
REFERENCE_TYPE

accept(PRIMITIVE_TYPE, repeatOf(ANNOTATION), NUMERIC_TYPE)
accept(PRIMITIVE_TYPE, repeatOf(ANNOTATION), T.BOOLEAN)

branch(NUMERIC_TYPE)
INTEGRAL_TYPE,
FLOATING_POINT_TYPE

branch(INTEGRAL_TYPE)
T.BYTE,
T.SHORT,
T.INT,
T.LONG,
T.CHAR

branch(FLOATING_POINT_TYPE)
T.FLOAT,
T.DOUBLE

branch(REFERENCE_TYPE)
CLASS_OR_INTERFACE_TYPE,
TYPE_VARIABLE,
ARRAY_TYPE

branch(CLASS_OR_INTERFACE_TYPE)
CLASS_TYPE,
INTERFACE_TYPE

accept(CLASS_TYPE, repeatOf(ANNOTATION), TYPE_IDENTIFIER, optional(TYPE_ARGUMENTS))
accept(CLASS_TYPE, PACKAGE_NAME, repeatOf(ANNOTATION), TYPE_IDENTIFIER, optional(TYPE_ARGUMENTS))
accept(CLASS_TYPE, CLASS_OR_INTERFACE_TYPE, repeatOf(ANNOTATION), TYPE_IDENTIFIER, optional(TYPE_ARGUMENTS))

accept(INTERFACE_TYPE, CLASS_TYPE)

accept(TYPE_VARIABLE, repeatOf(ANNOTATION), TYPE_IDENTIFIER)

accept(ARRAY_TYPE, PRIMITIVE_TYPE, DIMS)
accept(ARRAY_TYPE, CLASS_OR_INTERFACE_TYPE, DIMS)
accept(ARRAY_TYPE, TYPE_VARIABLE, DIMS)

accept(DIMS, repeatOf(ANNOTATION), T.LEFT_SQUARE_BRACKET, T.RIGHT_SQUARE_BRACKET, repeatOf(repeatOf(ANNOTATION), T.LEFT_SQUARE_BRACKET, T.RIGHT_SQUARE_BRACKET))

accept(TYPE_PARAMETER, repeatOf(TYPE_PARAMETER_MODIFIER), TYPE_IDENTIFIER, optional(TYPE_BOUND))

accept(TYPE_PARAMETER_MODIFIER, ANNOTATION)

accept(TYPE_BOUND, T.EXTENDS, TYPE_VARIABLE)
accept(TYPE_BOUND, T.EXTENDS, CLASS_OR_INTERFACE_TYPE, repeatOf(ADDITIONAL_BOUND))

accept(ADDITIONAL_BOUND, T.AND, INTERFACE_TYPE)

accept(TYPE_ARGUMENTS, T.LESS_THAN, TYPE_ARGUMENT_LIST, T.GREATER_THAN)

accept(TYPE_ARGUMENT_LIST, TYPE_ARGUMENT, repeatOf(T.COMMA, TYPE_ARGUMENT))

branch(TYPE_ARGUMENT)
REFERENCE_TYPE,
WILDCARD

accept(WILDCARD, repeatOf(ANNOTATION), T.QUESTION, optional(WILDCARD_BOUNDS))

accept(WILDCARD_BOUNDS, T.EXTENDS, REFERENCE_TYPE)
accept(WILDCARD_BOUNDS, T.SUPER, REFERENCE_TYPE)

//Productions from section ï¼–(Names):
accept(MODULE_NAME, IDENTIFIER)
accept(MODULE_NAME, MODULE_NAME, T.PERIOD, IDENTIFIER)

accept(PACKAGE_NAME, IDENTIFIER)
accept(PACKAGE_NAME, PACKAGE_NAME, T.PERIOD, IDENTIFIER)

accept(TYPE_NAME, TYPE_IDENTIFIER)
accept(TYPE_NAME, PACKAGE_OR_TYPE_NAME, T.PERIOD, TYPE_IDENTIFIER)

accept(EXPRESSION_NAME, IDENTIFIER)
accept(EXPRESSION_NAME, AMBIGUOUS_NAME, T.PERIOD, IDENTIFIER)

accept(METHOD_NAME, UNQUALIFIED_METHOD_IDENTIFIER)

accept(PACKAGE_OR_TYPE_NAME, IDENTIFIER)
accept(PACKAGE_OR_TYPE_NAME, PACKAGE_OR_TYPE_NAME, T.PERIOD, IDENTIFIER)

accept(AMBIGUOUS_NAME, IDENTIFIER)
accept(AMBIGUOUS_NAME, AMBIGUOUS_NAME, T.PERIOD, IDENTIFIER)

//Productions from section 7(Packages and Modules):
branch(COMPILATION_UNIT)
ORDINARY_COMPILATION_UNIT,
MODULAR_COMPILATION_UNIT

/* In the specification, there was an indention after the symbol{ImportDeclaration}, which means a division between productions.
 I ignored the indention and conbined the productions because separating the two was obviously weird.*/
accept(ORDINARY_COMPILATION_UNIT, optional(PACKAGE_DECLARATION), repeatOf(IMPORT_DECLARATION), repeatOf(TOP_LEVEL_CLASS_OR_INTERFACE_DECLARATION))

accept(MODULAR_COMPILATION_UNIT, repeatOf(IMPORT_DECLARATION), MODULE_DECLARATION)

accept(PACKAGE_DECLARATION, repeatOf(PACKAGE_MODIFIER), T.PACKAGE, IDENTIFIER, repeatOf(T.PERIOD, IDENTIFIER), T.SEMICOLON)

accept(PACKAGE_MODIFIER, ANNOTATION)

branch(IMPORT_DECLARATION)
SINGLE_TYPE_IMPORT_DECLARATION,
TYPE_IMPORT_ON_DEMAND_DECLARATION,
SINGLE_STATIC_IMPORT_DECLARATION,
STATIC_IMPORT_ON_DEMAND_DECLARATION

accept(SINGLE_TYPE_IMPORT_DECLARATION, T.IMPORT, TYPE_NAME, T.SEMICOLON)

accept(TYPE_IMPORT_ON_DEMAND_DECLARATION, T.IMPORT, PACKAGE_OR_TYPE_NAME, T.PERIOD, T.ASTERISK, T.SEMICOLON)

accept(SINGLE_STATIC_IMPORT_DECLARATION, T.IMPORT, T.STATIC, TYPE_NAME, T.PERIOD, IDENTIFIER, T.SEMICOLON)

accept(STATIC_IMPORT_ON_DEMAND_DECLARATION, T.IMPORT, T.STATIC, TYPE_NAME, T.PERIOD, T.ASTERISK, T.SEMICOLON)

branch(TOP_LEVEL_CLASS_OR_INTERFACE_DECLARATION)
CLASS_DECLARATION,
INTERFACE_DECLARATION,
T.SEMICOLON

accept(MODULE_DECLARATION, repeatOf(ANNOTATION), optional(T.OPEN), T.MODULE, IDENTIFIER, repeatOf(T.PERIOD, IDENTIFIER), T.LEFT_CURLY_BRACKET, repeatOf(MODULE_DIRECTIVE), T.RIGHT_CURLY_BRACKET)

accept(MODULE_DIRECTIVE, T.REQUIRES, repeatOf(REQUIRES_MODIFIER), MODULE_NAME, T.SEMICOLON)
accept(MODULE_DIRECTIVE, T.EXPORTS, PACKAGE_NAME, optional(T.TO, MODULE_NAME, repeatOf(T.COMMA, MODULE_NAME)), T.SEMICOLON)
accept(MODULE_DIRECTIVE, T.OPENS, PACKAGE_NAME, optional(T.TO, MODULE_NAME, repeatOf(T.COMMA, MODULE_NAME)), T.SEMICOLON)
accept(MODULE_DIRECTIVE, TYPE_NAME, T.SEMICOLON)
accept(MODULE_DIRECTIVE, T.PROVIDES, TYPE_NAME, T.WITH, TYPE_NAME, repeatOf(T.COMMA, TYPE_NAME), T.SEMICOLON)

branch(REQUIRES_MODIFIER)
T.TRANSITIVE,
T.STATIC

//Productions from section 8(Classes):
branch(CLASS_DECLARATION)
NORMAL_CLASS_DECLARATION,
ENUM_DECLARATION,
RECORD_DECLARATION

accept(NORMAL_CLASS_DECLARATION, repeatOf(CLASS_MODIFIER), T.CLASS, TYPE_IDENTIFIER, optional(TYPE_PARAMETERS), optional(CLASS_EXTENDS), optional(CLASS_IMPLEMENTS), optional(CLASS_PERMITS), CLASS_BODY)

branch(CLASS_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.PROTECTED,
T.PRIVATE,
T.ABSTRACT,
T.STATIC,
T.FINAL,
T.SEALED,
T.NON_SEALED,
T.STRICTFP

accept(TYPE_PARAMETERS, T.LESS_THAN, TYPE_PARAMETER_LIST, T.GREATER_THAN)

accept(TYPE_PARAMETER_LIST, TYPE_PARAMETER, repeatOf(T.COMMA, TYPE_PARAMETER))

accept(CLASS_EXTENDS, T.EXTENDS, CLASS_TYPE)

accept(CLASS_IMPLEMENTS, T.IMPLEMENTS, INTERFACE_TYPE_LIST)

accept(INTERFACE_TYPE_LIST, INTERFACE_TYPE, repeatOf(T.COMMA, INTERFACE_TYPE))

accept(CLASS_PERMITS, T.PERMITS, TYPE_NAME, repeatOf(T.COMMA, TYPE_NAME))

accept(CLASS_BODY, T.LEFT_CURLY_BRACKET, repeatOf(CLASS_BODY_DECLARATION), T.RIGHT_CURLY_BRACKET)

branch(CLASS_BODY_DECLARATION)
CLASS_MEMBER_DECLARATION,
INSTANCE_INITIALIZER,
STATIC_INITIALIZER,
CONSTRUCTOR_DECLARATION

branch(CLASS_MEMBER_DECLARATION)
FIELD_DECLARATION,
METHOD_DECLARATION,
CLASS_DECLARATION,
INTERFACE_DECLARATION,
T.SEMICOLON

accept(FIELD_DECLARATION, repeatOf(FIELD_MODIFIER), UNANN_TYPE, VARIABLE_DECLARATOR_LIST, T.SEMICOLON)

branch(FIELD_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.PROTECTED,
T.PRIVATE,
T.STATIC,
T.FINAL,
T.TRANSIENT,
T.VOLATILE

accept(VARIABLE_DECLARATOR_LIST, VARIABLE_DECLARATOR, repeatOf(T.COMMA, VARIABLE_DECLARATOR))

accept(VARIABLE_DECLARATOR, VARIABLE_DECLARATOR_ID, optional(T.SIMPLE_ASSIGNMENT, VARIABLE_INITIALIZER))

accept(VARIABLE_DECLARATOR_ID, IDENTIFIER, optional(DIMS))

branch(VARIABLE_INITIALIZE)
EXPRESSION,
ARRAY_INITIALIZER

branch(UNANN_TYPE)
UNANN_PRIMITIVE_TYPE,
UNANN_REFERENCE_TYPE

branch(UNANN_PRIMITIVE_TYPE)
NUMERIC_TYPE,
T.BOOLEAN

branch(UNANN_REFERENCE_TYPE)
UNANN_CLASS_OR_INTERFACE_TYPE,
UNANN_TYPE_VARIABLE,
UNANN_ARRAY_TYPE

branch(UNANN_CLASS_OR_INTERFACE_TYPE)
UNANN_CLASS_TYPE,
UNANN_INTERFACE_TYPE

accept(UNANN_CLASS_TYPE, TYPE_IDENTIFIER, optional(TYPE_ARGUMENTS))
accept(UNANN_CLASS_TYPE, PACKAGE_NAME, T.PERIOD, repeatOf(ANNOTATION), TYPE_IDENTIFIER, optional(TYPE_ARGUMENTS))
accept(UNANN_CLASS_TYPE, UNANN_CLASS_OR_INTERFACE_TYPE, T.PERIOD, repeatOf(ANNOTATION), TYPE_IDENTIFIER, optional(TYPE_ARGUMENTS))

accept(UNANN_INTERFACE_TYPE, UNANN_CLASS_TYPE)

accept(UNANN_TYPE_VARIABLE, TYPE_IDENTIFIER)

accept(UNANN_ARRAY_TYPE, UNANN_PRIMITIVE_TYPE, DIMS)
accept(UNANN_ARRAY_TYPE, UNANN_CLASS_OR_INTERFACE_TYPE, DIMS)
accept(UNANN_ARRAY_TYPE, UNANN_TYPE_VARIABLE, DIMS)

accept(METHOD_DECLARATION, repeatOf(METHOD_MODIFIER), METHOD_HEADER, METHOD_BODY)

branch(METHOD_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.PROTECTED,
T.PRIVATE,
T.ABSTRACT,
T.STATIC,
T.FINAL,
T.SYNCHRONIZED,
T.NATIVE,
T.STRICTFP

accept(METHOD_HEADER, RESULT, METHOD_DECLARATOR, optional(THROWS))
accept(METHOD_HEADER, TYPE_PARAMETERS, repeatOf(ANNOTATION), RESULT, METHOD_DECLARATOR, optional(THROWS))

branch(RESULT)
UNANN_TYPE,
T.VOID

accept(METHOD_DECLARATOR, IDENTIFIER, T.LEFT_ROUND_BRACKET, optional(RECEIVER_PARAMETER, T.COMMA), optional(FORMAL_PARAMETER_LIST), T.RIGHT_ROUND_BRACKET, optional(DIMS))

accept(RECEIVER_PARAMETER, repeatOf(ANNOTATION), UNANN_TYPE, optional(IDENTIFIER, T.PERIOD), T.THIS)

accept(FORMAL_PARAMETER_LIST, FORMAL_PARAMETER, repeatOf(T.COMMA, FORMAL_PARAMETER))

accept(FORMAL_PARAMETER, repeatOf(VARIABLE_MODIFIER), UNANN_TYPE, VARIABLE_DECLARATOR_ID)
accept(FORMAL_PARAMETER, VARIABLE_ARITY_PARAMETER)

accept(VARIABLE_ARITY_PARAMETER, repeatOf(VARIABLE_MODIFIER), UNANN_TYPE, repeatOf(ANNOTATION), T.ELLIPSIS, IDENTIFIER)

branch(VARIABLE_MODIFIER)
ANNOTATION,
T.FINAL

accept(THROWS, T.THROWS, EXCEPTION_TYPE_LIST)

accept(EXCEPTION_TYPE_LIST, EXCEPTION_TYPE, repeatOf(T.COMMA, EXCEPTION_TYPE))

branch(EXCEPTION_TYPE)
CLASS_TYPE,
TYPE_VARIABLE

branch(METHOD_BODY)
BLOCK,
T.SEMICOLON

accept(INSTANCE_INITIALIZER, BLOCK)

accept(STATIC_INITIALIZER, T.STATIC, BLOCK)

accept(CONSTRUCTOR_DECLARATION, repeatOf(CONSTRUCTOR_MODIFIER), CONSTRUCTOR_DECLARATOR, optional(THROWS), CONSTRUCTOR_BODY)

branch(CONSTRUCTOR_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.PROTECTED,
T.PRIVATE

accept(CONSTRUCTOR_DECLARATOR, optional(TYPE_PARAMETERS), SIMPLE_TYPE_NAME, T.LEFT_ROUND_BRACKET, optional(RECEIVER_PARAMETER, T.COMMA), optional(FORMAL_PARAMETER_LIST), T.RIGHT_ROUND_BRACKET)

accept(SIMPLE_TYPE_NAME, TYPE_IDENTIFIER)

accept(CONSTRUCTOR_BODY, T.LEFT_CURLY_BRACKET, optional(EXPLICIT_CONSTRUCTOR_INVOCATION), optional(BLOCK_STATEMENT), T.RIGHT_CURLY_BRACKET)

accept(EXPLICIT_CONSTRUCTOR_INVOCATION, optional(TYPE_ARGUMENTS), T.THIS, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET, T.SEMICOLON)
accept(EXPLICIT_CONSTRUCTOR_INVOCATION, optional(TYPE_ARGUMENTS), T.SUPER, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET, T.SEMICOLON)
accept(EXPLICIT_CONSTRUCTOR_INVOCATION, EXPRESSION_NAME, T.PERIOD, optional(TYPE_ARGUMENTS), T.THIS, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET, T.SEMICOLON)
accept(EXPLICIT_CONSTRUCTOR_INVOCATION, PRIMARY, T.PERIOD, optional(TYPE_ARGUMENTS), T.THIS, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET, T.SEMICOLON)

accept(ENUM_DECLARATION, repeatOf(CLASS_MODIFIER), T.ENUM, TYPE_IDENTIFIER, optional(CLASS_IMPLEMENTS), ENUM_BODY)

accept(ENUM_BODY, T.LEFT_CURLY_BRACKET, optional(ENUM_CONSTANT_LIST), optional(T.COMMA), optional(ENUM_BODY_DECLARATIONS))

accept(ENUM_CONSTANT_LIST, ENUM_CONSTANT, repeatOf(T.COMMA, ENUM_CONSTANT))

accept(ENUM_CONSTANT, repeatOf(ENUM_CONSTANT_MODIFIER), IDENTIFIER, optional(T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET), optional(CLASS_BODY))

accept(ENUM_CONSTANT_MODIFIER, ANNOTATION)

accept(ENUM_BODY_DECLARATIONS, T.SEMICOLON, repeatOf(CLASS_BODY_DECLARATION))

accept(RECORD_DECLARATION, repeatOf(CLASS_MODIFIER), T.RECORD, TYPE_IDENTIFIER, optional(TYPE_PARAMETERS), RECORD_HEADER, optional(CLASS_IMPLEMENTS), RECORD_BODY)

accept(RECORD_HEADER, T.LEFT_ROUND_BRACKET, optional(RECORD_COMPONENT_LIST), T.RIGHT_ROUND_BRACKET)

accept(RECORD_COMPONENT_LIST, RECORD_COMPONENT, optional(T.COMMA, RECORD_COMPONENT))

accept(RECORD_COMPONENT, repeatOf(RECORD_COMPONENT_MODIFIER), UNANN_TYPE, IDENTIFIER)
accept(VARIABLE_ARITY_RECORD_COMPONENT)

accept(VARIABLE_ARITY_RECORD_COMPONENT, repeatOf(RECORD_COMPONENT_MODIFIER), UNANN_TYPE, repeatOf(ANNOTATION), T.ELLIPSIS, IDENTIFIER)

accept(RECORD_COMPONENT_MODIFIER, ANNOTATION)

accept(RECORD_BODY, T.LEFT_CURLY_BRACKET, repeatOf(RECORD_BODY_DECLARATION), T.RIGHT_CURLY_BRACKET)

branch(RECORD_BODY_DECLARATION)
CLASS_BODY_DECLARATION,
COMPACT_CONSTRUCTOR_DECLARATION

accept(COMPACT_CONSTRUCTOR_DECLARATION, repeatOf(CONSTRUCTOR_MODIFIER), SIMPLE_TYPE_NAME, CONSTRUCTOR_BODY)

//Productions from section 9(Interfaces):
branch(INTERFACE_DECLARATION)
NORMAL_INTERFACE_DECLARATION,
ANNOTATION_INTERFACE_DECLARATION

accept(NORMAL_INTERFACE_DECLARATION, repeatOf(INTERFACE_MODIFIER), T.INTERFACE, TYPE_IDENTIFIER, optional(TYPE_PARAMETERS), optional(INTERFACE_EXTENDS), optional(INTERFACE_PERMITS), INTERFACE_BODY)

branch(INTERFACE_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.PROTECTED,
T.PRIVATE,
T.ABSTRACT,
T.STATIC,
T.SEALED,
T.NON_SEALED,
T.STRICTFP

accept(INTERFACE_EXTENDS, T.EXTENDS, INTERFACE_TYPE_LIST)

accept(INTERFACE_PERMITS, T.PERMITS, TYPE_NAME, repeatOf(T.COMMA, TYPE_NAME))

accept(INTERFACE_BODY, T.LEFT_CURLY_BRACKET, repeatOf(INTERFACE_MEMBER_DECLARATION), T.RIGHT_CURLY_BRACKET)

branch(INTERFACE_MEMBER_DECLARATION)
CONSTANT_DECLARATION,
INTERFACE_METHOD_DECLARATION,
CLASS_DECLARATION,
INTERFACE_DECLARATION,
T.SEMICOLON

accept(CONSTANT_DECLARATION, repeatOf(CONSTANT_MODIFIER), UNANN_TYPE, VARIABLE_DECLARATOR_LIST, T.SEMICOLON)

branch(CONSTANT_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.STATIC,
T.FINAL

accept(INTERFACE_METHOD_DECLARATION, repeatOf(INTERFACE_METHOD_MODIFIER), METHOD_HEADER, METHOD_BODY)

branch(INTERFACE_METHOD_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.PRIVATE,
T.ABSTRACT,
T.DEFAULT,
T.STATIC,
T.STRICTFP

accept(ANNOTATION_INTERFACE_DECLARATION, repeatOf(INTERFACE_MODIFIER), T.AT_SIGN, T.INTERFACE, TYPE_IDENTIFIER, ANNOTATION_INTERFACE_BODY)

accept(ANNOTATION_INTERFACE_BODY, T.LEFT_CURLY_BRACKET, repeatOf(ANNOTATION_INTERFACE_MEMBER_DECLARATION), T.RIGHT_CURLY_BRACKET)

branch(ANNOTATION_INTERFACE_MEMBER_DECLARATION)
ANNOTATION_INTERFACE_ELEMENT_DECLARATION,
CONSTANT_DECLARATION,
CLASS_DECLARATION,
INTERFACE_DECLARATION,
T.SEMICOLON

accept(ANNOTATION_INTERFACE_ELEMENT_DECLARATION, repeatOf(ANNOTATION_INTERFACE_ELEMENT_MODIFIER), UNANN_TYPE, IDENTIFIER, T.LEFT_ROUND_BRACKET, T.RIGHT_ROUND_BRACKET, optional(DIMS), optional(DEFAULT_VALUE), T.SEMICOLON)

branch(ANNOTATION_INTERFACE_ELEMENT_MODIFIER)
ANNOTATION,
T.PUBLIC,
T.ABSTRACT

accept(DEFAULT_VALUE, T.DEFAULT, ELEMENT_VALUE)

branch(ANNOTATION)
NORMAL_ANNOTATION,
MARKER_ANNOTATION,
SINGLE_ELEMENT_ANNOTATION

accept(NORMAL_ANNOTATION, T.AT_SIGN, TYPE_NAME, T.LEFT_ROUND_BRACKET, optional(ELEMENT_VALUE_PAIR_LIST), T.RIGHT_ROUND_BRACKET)

accept(ELEMENT_VALUE_PAIR_LIST, ELEMENT_VALUE_PAIR, repeatOf(T.COMMA, ELEMENT_VALUE_PAIR))

accept(ELEMENT_VALUE_PAIR, IDENTIFIER, T.SIMPLE_ASSIGNMENT, ELEMENT_VALUE)

branch(ELEMENT_VALUE)
CONDITIONAL_EXPRESSION,
ELEMENT_VALUE_ARRAY_INITIALIZER,
ANNOTATION

accept(ELEMENT_VALUE_ARRAY_INITIALIZER, T.LEFT_CURLY_BRACKET, optional(ELEMENT_VALUE_LIST), optional(T.COMMA), T.RIGHT_CURLY_BRACKET)

accept(ELEMENT_VALUE_LIST, ELEMENT_VALUE, repeatOf(T.COMMA, ELEMENT_VALUE))

accept(MARKER_ANNOTATION, T.AT_SIGN, TYPE_NAME)

accept(SINGLE_ELEMENT_ANNOTATION, T.AT_SIGN, TYPE_NAME, T.LEFT_ROUND_BRACKET, ELEMENT_VALUE, T.RIGHT_ROUND_BRACKET)

//Productions from section 10(Arrays):
accept(ARRAY_INITIALIZER, T.LEFT_CURLY_BRACKET, optional(VARIABLE_INITIALIZER_LIST), optional(T.COMMA), T.RIGHT_CURLY_BRACKET)

accept(VARIABLE_INITIALIZER_LIST, VARIABLE_INITIALIZER, repeatOf(T.COMMA, VARIABLE_INITIALIZER))

//Productions from section 14(Blocks, Statements, and Patterns):
accept(BLOCK, T.LEFT_CURLY_BRACKET, optional(BLOCK_STATEMENTS), T.RIGHT_CURLY_BRACKET)

accept(BLOCK_STATEMENTS, BLOCK_STATEMENT, repeatOf(BLOCK_STATEMENT))

branch(BLOCK_STATEMENT)
LOCAL_CLASS_OR_INTERFACE_DECLARATION,
LOCAL_VARIABLE_DECLARATION_STATEMENT,
STATEMENT

branch(LOCAL_CLASS_OR_INTERFACE_DECLARATION,
CLASS_DECLARATION,
NORMAL_INTERFACE_DECLARATION)

accept(LOCAL_VARIABLE_DECLARATION_STATEMENT, LOCAL_VARIABLE_DECLARATION, T.SEMICOLON)

accept(LOCAL_VARIABLE_DECLARATION, repeatOf(VARIABLE_MODIFIER), LOCAL_VARIABLE_TYPE, VARIABLE_DECLARATOR_LIST)

branch(LOCAL_VARIABLE_TYPE)
UNANN_TYPE,
T.VAR

branch(STATEMENT)
STATEMENT_WITHOUT_TRAILING_SUBSTATEMENT,
LABELED_STATEMENT,
IF_THEN_STATEMENT,
IF_THEN_ELSE_STATEMENT,
WHILE_STATEMENT,
FOR_STATEMENT

branch(STATEMENT_NO_SHORT_IF)
STATEMENT_WITHOUT_TRAILING_SUBSTATEMENT,
LABELED_STATEMENT_NO_SHORT_IF,
IF_THEN_ELSE_STATEMENT_NO_SHORT_IF,
WHILE_STATEMENT_NO_SHORT_IF,
FOR_STATEMENT_NO_SHORT_IF

branch(STATEMENT_WITHOUT_TRAILING_SUBSTATEMENT)
BLOCK,
EMPTY_STATEMENT,
EXPRESSION_STATEMENT,
ASSERT_STATEMENT,
SWITCH_STATEMENT,
DO_STATEMENT,
BREAK_STATEMENT,
CONTINUE_STATEMENT,
RETURN_STATEMENT,
SYNCHRONIZED_STATEMENT,
THROW_STATEMENT,
TRY_STATEMENT,
YIELD_STATEMENT

accept(EMPTY_STATEMENT, T.SEMICOLON)

accept(LABELED_STATEMENT, IDENTIFIER, T.COLON, STATEMENT)

accept(LABELED_STATEMENT_NO_SHORT_IF, IDENTIFIER, T.COLON, STATEMENT_NO_SHORT_IF)

accept(EXPRESSION_STATEMENT, STATEMENT_EXPRESSION, T.SEMICOLON)

branch(STATEMENT_EXPRESSION)
ASSIGNMENT,
PRE_INCREMENT_EXPRESSION,
PRE_DECREMENT_EXPRESSION,
POST_INCREMENT_EXPRESSION,
POST_DECREMENT_EXPRESSION,
METHOD_INVOCATION,
CLASS_INSTANCE_CREATION_EXPRESSION

accept(IF_THEN_STATEMENT, T.IF, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT)

accept(IF_THEN_ELSE_STATEMENT, T.IF, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT_NO_SHORT_IF, T.ELSE, STATEMENT)

accept(IF_THEN_ELSE_STATEMENT_NO_SHORT_IF, T.IF, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT_NO_SHORT_IF, T.ELSE, STATEMENT_NO_SHORT_IF)

accept(ASSERT_STATEMENT, EXPRESSION, T.SEMICOLON)
accept(ASSERT_STATEMENT, EXPRESSION, T.COLON, EXPRESSION, T.SEMICOLON)

accept(SWITCH_STATEMENT, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, SWITCH_BLOCK)

accept(SWITCH_BLOCK, T.LEFT_CURLY_BRACKET, SWITCH_RULE, repeatOf(SWITCH_RULE), T.RIGHT_CURLY_BRACKET)
accept(SWITCH_BLOCK, T.LEFT_CURLY_BRACKET, repeatOf(SWITCH_BLOCK_STATEMENT_GROUP), repeatOf(SWITCH_LABEL, T.COLON), T.RIGHT_CURLY_BRACKET)

accept(SWITCH_RULE, SWITCH_LABEL, T.ARROW, EXPRESSION, T.SEMICOLON)
accept(SWITCH_RULE, SWITCH_LABEL, T.ARROW, BLOCK)
accept(SWITCH_RULE, SWITCH_LABEL, T.ARROW, THROW_STATEMENT)

accept(SWITCH_BLOCK_STATEMENT_GROUP, SWITCH_LABEL, T.COLON, repeatOf(SWITCH_LABEL, T.COLON), BLOCK_STATEMENTS)

accept(SWITCH_LABEL, T.CASE, CASE_CONSTANT, repeatOf(T.COMMA, CASE_CONSTANT))
accept(SWITCH_LABEL, T.DEFAULT)

accept(CASE_CONSTANT, CONDITIONAL_EXPRESSION)

accept(WHILE_STATEMENT, T.WHILE, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT)

accept(WHILE_STATEMENT_NO_SHORT_IF, T.WHILE, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT_NO_SHORT_IF)

accept(DO_STATEMENT, T.DO, STATEMENT, T.WHILE, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, T.SEMICOLON)

branch(FOR_STATEMENT)
BASIC_FOR_STATEMENT,
ENHANCED_FOR_STATEMENT)

branch(FOR_STATEMENT_NO_SHORT_IF)
BASIC_FOR_STATEMENT_NO_SHORT_IF,
ENHANCED_FOR_STATEMENT_NO_SHORT_IF

accept(BASIC_FOR_STATEMENT, T.FOR, T.LEFT_ROUND_BRACKET, optional(FOR_INIT), T.SEMICOLON, optional(EXPRESSION), T.SEMICOLON, optional(FOR_UPDATE), T.RIGHT_ROUND_BRACKET, STATEMENT)

accept(BASIC_FOR_STATEMENT_NO_SHORT_IF, T.FOR, T.LEFT_ROUND_BRACKET, optional(FOR_INIT), T.SEMICOLON, optional(EXPRESSION), T.SEMICOLON, optional(FOR_UPDATE), T.RIGHT_ROUND_BRACKET, STATEMENT_NO_SHORT_IF)

branch(FOR_INIT)
STATEMENT_EXPRESSION_LIST,
LOCAL_VARIABLE_DECLARATION

accept(FOR_UPDATE, STATEMENT_EXPRESSION_LIST)

accept(STATEMENT_EXPRESSION_LIST, STATEMENT_EXPRESSION, repeatOf(T.COMMA, STATEMENT_EXPRESSION))

accept(ENHANCED_FOR_STATEMENT, T.FOR, T.LEFT_ROUND_BRACKET, LOCAL_VARIABLE_DECLARATION, T.COLON, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT)

accept(ENHANCED_FOR_STATEMENT_NO_SHORT_IF, T.FOR, T.LEFT_ROUND_BRACKET, LOCAL_VARIABLE_DECLARATION, T.COLON, EXPRESSION, T.RIGHT_ROUND_BRACKET, STATEMENT_NO_SHORT_IF)

accept(BREAK_STATEMENT, T.BREAK, optional(IDENTIFIER), T.SEMICOLON)

accept(YIELD_STATEMENT, T.YIELD, EXPRESSION, T.SEMICOLON)

accept(CONTINUE_STATEMENT, T.CONTINUE, optional(IDENTIFIER), T.SEMICOLON)

accept(RETURN_STATEMENT, T.RETURN, optional(EXPRESSION), T.SEMICOLON)

accept(THROW_STATEMENT, T.THROW, EXPRESSION, T.SEMICOLON)

accept(SYNCHRONIZED_STATEMENT, T.LEFT_ROUND_BRACKET,T.SYNCHRONIZED, T.RIGHT_ROUND_BRACKET, BLOCK)

accept(TRY_STATEMENT, T.TRY, BLOCK, CATCHES)
accept(TRY_STATEMENT, T.TRY, BLOCK, optional(CATCHES), FINALLY)
accept(TRY_STATEMENT, TRY_WITH_RESOURCES_STATEMENT)

accept(CATCHES, CATCH_CLAUSE, repeatOf(CATCH_CLAUSE))

accept(CATCH_CLAUSE, T.CATCH, T.LEFT_ROUND_BRACKET, CATCH_FORMAL_PARAMETER, T.RIGHT_ROUND_BRACKET, BLOCK)

accept(CATCH_FORMAL_PARAMETER, repeatOf(VARIABLE_MODIFIER), CATCH_TYPE, VARIABLE_DECLARATOR_ID)

accept(CATCH_TYPE, UNANN_CLASS_TYPE, repeatOf(T.VERTICAL_BAR, CLASS_TYPE))

accept(FINALLY, T.FINALLY, BLOCK)

accept(TRY_WITH_RESOURCES_STATEMENT, T.TRY, RESOURCE_SPECIFICATION, BLOCK, optional(CATCHES), optional(FINALLY))

accept(RESOURCE_SPECIFICATION, T.LEFT_ROUND_BRACKET, RESOURCE_LIST, optional(T.SEMICOLON), T.RIGHT_ROUND_BRACKET)

accept(RESOURCE_LIST, RESOURCE, repeatOf(T.SEMICOLON, RESOURCE))

branch(RESOURCE)
LOCAL_VARIABLE_DECLARATION,
VARIABLE_ACCESS

//This rule is missing in chapter 19 of the specification, but it's expected to be here.
branch(VARIABLE_ACCESS)
EXPRESSION_NAME,
FIELD_ACCESS

accept(PATTERN, TYPE_PATTERN)

accept(TYPE_PATTERN, LOCAL_VARIABLE_DECLARATION)

//Productions from section 15(Expressions):
branch(PRIMARY)
PRIMARY_NO_NEW_ARRAY, 
ARRAY_CREATION_EXPRESSION //

accept(PRIMARY_NO_NEW_ARRAY, LITERAL) //
accept(PRIMARY_NO_NEW_ARRAY, CLASS_LITERAL) //
accept(PRIMARY_NO_NEW_ARRAY, T.THIS) //
accept(PRIMARY_NO_NEW_ARRAY, TYPE_NAME, T.PERIOD, T.THIS) //
accept(PRIMARY_NO_NEW_ARRAY, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET) //
accept(PRIMARY_NO_NEW_ARRAY, CLASS_INSTANCE_CREATION_EXPRESSION) //
accept(PRIMARY_NO_NEW_ARRAY, FIELD_ACCESS) //
accept(PRIMARY_NO_NEW_ARRAY, ARRAY_ACCESS) //
accept(PRIMARY_NO_NEW_ARRAY, METHOD_INVOCATION) //
accept(PRIMARY_NO_NEW_ARRAY, METHOD_REFERENCE) //

accept(CLASS_LITERAL, TYPE_NAME, repeatOf(T.LEFT_SQUARE_BRACKET, T.RIGHT_SQUARE_BRACKET), T.PERIOD, T.CLASS) //
accept(CLASS_LITERAL, NUMERIC_TYPE, repeatOf(T.LEFT_SQUARE_BRACKET, T.RIGHT_SQUARE_BRACKET), T.PERIOD, T.CLASS) //
accept(CLASS_LITERAL, T.BOOLEAN, repeatOf(T.LEFT_SQUARE_BRACKET, T.RIGHT_SQUARE_BRACKET), T.PERIOD, T.CLASS) //
accept(CLASS_LITERAL, T.VOID, T.PERIOD, T.CLASS) //

accept(CLASS_INSTANCE_CREATION_EXPRESSION, UNQUALIFIED_CLASS_INSTANCE_CREATION_EXPRESSION) //
accept(CLASS_INSTANCE_CREATION_EXPRESSION, EXPRESSION_NAME, T.PERIOD, UNQUALIFIED_CLASS_INSTANCE_CREATION_EXPRESSION) //
accept(CLASS_INSTANCE_CREATION_EXPRESSION, PRIMARY, T.PERIOD, UNQUALIFIED_CLASS_INSTANCE_CREATION_EXPRESSION) //

accept(UNQUALIFIED_CLASS_INSTANCE_CREATION_EXPRESSION, T.NEW, optional(TYPE_ARGUMENTS), CLASS_OR_INTERFACE_TYPE_TO_INSTANTIATE, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET, optional(CLASS_BODY))

accept(CLASS_OR_INTERFACE_TYPE_TO_INSTANTIATE, repeatOf(ANNOTATION), IDENTIFIER, repeatOf(T.PERIOD, repeatOf(ANNOTATION), IDENTIFIER), optional(TYPE_ARGUMENTS_OR_DIAMOND))

accept(TYPE_ARGUMENTS_OR_DIAMOND, TYPE_ARGUMENTS)
accept(TYPE_ARGUMENTS_OR_DIAMOND, T.LESS_THAN, T.GREATER_THAN)

accept(FIELD_ACCESS, PRIMARY, T.PERIOD, IDENTIFIER) //
accept(FIELD_ACCESS, T.SUPER, T.PERIOD, IDENTIFIER) //
accept(FIELD_ACCESS, TYPE_NAME, T.PERIOD, T.SUPER, T.PERIOD, IDENTIFIER) //

accept(ARRAY_ACCESS, EXPRESSION_NAME, T.LEFT_SQUARE_BRACKET, EXPRESSION, T.RIGHT_SQUARE_BRACKET)
accept(ARRAY_ACCESS, PRIMARY_NO_NEW_ARRAY, T.LEFT_SQUARE_BRACKET, EXPRESSION, T.RIGHT_SQUARE_BRACKET)

accept(METHOD_INVOCATION, METHOD_NAME, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET) //
accept(METHOD_INVOCATION, TYPE_NAME, T.PERIOD, optional(TYPE_ARGUMENTS), IDENTIFIER, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET) //
accept(METHOD_INVOCATION, EXPRESSION_NAME, T.PERIOD, optional(TYPE_ARGUMENTS), IDENTIFIER, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET) //
accept(METHOD_INVOCATION, PRIMARY, T.PERIOD, optional(TYPE_ARGUMENTS), IDENTIFIER, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET) //
accept(METHOD_INVOCATION, T.SUPER, T.PERIOD, optional(TYPE_ARGUMENTS), IDENTIFIER, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET) //
accept(METHOD_INVOCATION, TYPE_NAME, T.PERIOD, T.SUPER, T.PERIOD, optional(TYPE_ARGUMENTS), IDENTIFIER, T.LEFT_ROUND_BRACKET, optional(ARGUMENT_LIST), T.RIGHT_ROUND_BRACKET) //

accept(ARGUMENT_LIST, EXPRESSION, repeatOf(T.COMMA, EXPRESSION))

accept(METHOD_REFERENCE, EXPRESSION_NAME, T.DOUBLE_COLON, optional(TYPE_ARGUMENTS), IDENTIFIER) //
accept(METHOD_REFERENCE, PRIMARY, T.DOUBLE_COLON, optional(TYPE_ARGUMENTS), IDENTIFIER) //
accept(METHOD_REFERENCE, REFERENCE_TYPE, T.DOUBLE_COLON, optional(TYPE_ARGUMENTS), IDENTIFIER) //
accept(METHOD_REFERENCE, T.SUPER, T.DOUBLE_COLON, optional(TYPE_ARGUMENTS), IDENTIFIER) //
accept(METHOD_REFERENCE, TYPE_NAME, T.PERIOD, T.SUPER, T.DOUBLE_COLON, optional(TYPE_ARGUMENTS), IDENTIFIER) //
accept(METHOD_REFERENCE, CLASS_TYPE, T.DOUBLE_COLON, optional(TYPE_ARGUMENTS), T.NEW) //
accept(METHOD_REFERENCE, ARRAY_TYPE, T.DOUBLE_COLON, T.NEW) //

accept(ARRAY_CREATION_EXPRESSION, T.NEW, PRIMITIVE_TYPE, DIM_EXPRS, optional(DIMS)) //
accept(ARRAY_CREATION_EXPRESSION, T.NEW, CLASS_OR_INTERFACE_TYPE, DIM_EXPRS, optional(DIMS)) //
accept(ARRAY_CREATION_EXPRESSION, T.NEW, PRIMITIVE_TYPE, DIMS, ARRAY_INITIALIZER) //
accept(ARRAY_CREATION_EXPRESSION, T.NEW, CLASS_OR_INTERFACE_TYPE, DIMS, ARRAY_INITIALIZER) //

accept(DIM_EXPRS, DIM_EXPR, repeatOf(DIM_EXPR))

accept(DIM_EXPR, repeatOf(ANNOTATION), T.LEFT_SQUARE_BRACKET, EXPRESSION, T.RIGHT_SQUARE_BRACKET)

branch(EXPRESSION)
LAMBDA_EXPRESSION,
ASSIGNMENT_EXPRESSION

accept(LAMBDA_EXPRESSION, LAMBDA_PARAMETERS, T.ARROW, LAMBDA_BODY)

accept(LAMBDA_PARAMETERS, T.LEFT_ROUND_BRACKET, optional(LAMBDA_PARAMETER_LIST), T.RIGHT_ROUND_BRACKET)
accept(LAMBDA_PARAMETERS, IDENTIFIER)

accept(LAMBDA_PARAMETER_LIST, LAMBDA_PARAMETER, repeatOf(T.COMMA, LAMBDA_PARAMETER))
accept(LAMBDA_PARAMETER_LIST, IDENTIFIER, repeatOf(T.COMMA, IDENTIFIER))

accept(LAMBDA_PARAMETER, repeatOf(VARIABLE_MODIFIER), LAMBDA_PARAMETER_TYPE, VARIABLE_DECLARATOR_ID)
accept(VARIABLE_ARITY_PARAMETER)

branch(LAMBDA_PARAMETER_TYPE)
UNANN_TYPE,
T.VAR

branch(LAMBDA_BODY)
EXPRESSION,
BLOCK

branch(ASSIGNMENT_EXPRESSION)
CONDITIONAL_EXPRESSION,
ASSIGNMENT

accept(ASSIGNMENT, LEFT_HAND_SIDE, ASSIGNMENT_OPERATOR, EXPRESSION)

branch(LEFT_HAND_SIDE)
EXPRESSION_NAME,
FIELD_ACCESS,
ARRAY_ACCESS

branch(ASSIGNMENT_OPERATOR)
T.SIMPLE_ASSIGNMENT,
T.ASSIGNMENT_BY_PRODUCT,
T.ASSIGNMENT_BY_QUOTIENT,
T.ASSIGNMENT_BY_REMINDER,
T.ASSIGNMENT_BY_SUM,
T.ASSIGNMENT_BY_DIFFERENCE,
T.ASSIGNMENT_BY_BITWISE_LEFT_SHIFT,
T.ASSIGNMENT_BY_SIGNED_BITWISE_RIGHT_SHIFT,
T.ASSIGNMENT_BY_UNSIGNED_BITWISE_RIGHT_SHIFT,
T.ASSIGNMNET_BY_BITWISE_AND,
T.ASSIGNMENT_BY_BITWISE_XOR,
T.ASSIGNMENT_BY_BITWISE_OR

accept(CONDITIONAL_EXPRESSION, CONDITIONAL_OR_EXPRESSION)
accept(CONDITIONAL_EXPRESSION, CONDITIONAL_OR_EXPRESSION, T.QUESTION, EXPRESSION, T.COLON, CONDITIONAL_EXPRESSION)
accept(CONDITIONAL_EXPRESSION, CONDITIONAL_OR_EXPRESSION, T.QUESTION, EXPRESSION, T.COLON, LAMBDA_EXPRESSION)

accept(CONDITIONAL_OR_EXPRESSION, CONDITIONAL_AND_EXPRESSION)
accept(CONDITIONAL_OR_EXPRESSION, CONDITIONAL_OR_EXPRESSION, T.LOGICAL_CONDITIONAL_OR, CONDITIONAL_AND_EXPRESSION)

accept(CONDITIONAL_AND_EXPRESSION, INCLUSIVE_OR_EXPRESSION)
accept(CONDITIONAL_AND_EXPRESSION, CONDITIONAL_AND_EXPRESSION, T.LOGICAL_CONDITIONAL_AND, INCLUSIVE_OR_EXPRESSION)

accept(INCLUSIVE_OR_EXPRESSION, EXCLUSIVE_OR_EXPRESSION)
accept(INCLUSIVE_OR_EXPRESSION, INCLUSIVE_OR_EXPRESSION, T.VERTICAL_BAR, EXCLUSIVE_OR_EXPRESSION)

accept(EXCLUSIVE_OR_EXPRESSION, AND_EXPRESSION)
accept(EXCLUSIVE_OR_EXPRESSION, EXCLUSIVE_OR_EXPRESSION, T.BITWISE_AND_LOGICAL_XOR, AND_EXPRESSION)

accept(AND_EXPRESSION, EQUALITY_EXPRESSION)
accept(AND_EXPRESSION, AND_EXPRESSION, T.AND, EQUALITY_EXPRESSION)

accept(EQUALITY_EXPRESSION, RELATIONAL_EXPRESSION)
accept(EQUALITY_EXPRESSION, EQUALITY_EXPRESSION, T.EQUAL_TO, RELATIONAL_EXPRESSION)
accept(EQUALITY_EXPRESSION, EQUALITY_EXPRESSION, T.NOT_EQUAL_TO, RELATIONAL_EXPRESSION)

accept(RELATIONAL_EXPRESSION, SHIFT_EXPRESSION)
accept(RELATIONAL_EXPRESSION, RELATIONAL_EXPRESSION, T.LESS_THAN, SHIFT_EXPRESSION)
accept(RELATIONAL_EXPRESSION, RELATIONAL_EXPRESSION, T.GREATER_THAN, SHIFT_EXPRESSION)
accept(RELATIONAL_EXPRESSION, RELATIONAL_EXPRESSION, T.LESS_THAN_OR_EQUAL_TO, SHIFT_EXPRESSION)
accept(RELATIONAL_EXPRESSION, RELATIONAL_EXPRESSION, T.GRATER_THAN_OR_EQUAL_TO, SHIFT_EXPRESSION)
accept(RELATIONAL_EXPRESSION, INSTANCE_OF_EXPRESSION)

accept(INSTANCE_OF_EXPRESSION, RELATIONAL_EXPRESSION, T.INSTANCEOF, REFERENCE_TYPE)
accept(INSTANCE_OF_EXPRESSION, RELATIONAL_EXPRESSION, T.INSTANCEOF, PATTERN)

accept(SHIFT_EXPRESSION, ADDITIVE_EXPRESSION)
accept(SHIFT_EXPRESSION, SHIFT_EXPRESSION, T.BITWISE_LEFT_SHIFT, ADDITIVE_EXPRESSION)
accept(SHIFT_EXPRESSION, SHIFT_EXPRESSION, T.BITWISE_SIGNED_RIGHT_SHIFT, ADDITIVE_EXPRESSION)
accept(SHIFT_EXPRESSION, SHIFT_EXPRESSION, T.BITWISE_UNSIGNED_RIGHT_SHIFT, ADDITIVE_EXPRESSION)

accept(ADDITIVE_EXPRESSION, MULTIPLICATIVE_EXPRESSION)
accept(ADDITIVE_EXPRESSION, ADDITIVE_EXPRESSION, T.PLUS, MULTIPLICATIVE_EXPRESSION)
accept(ADDITIVE_EXPRESSION, ADDITIVE_EXPRESSION, T.MINUS, MULTIPLICATIVE_EXPRESSION)

accept(MULTIPLICATIVE_EXPRESSION, UNARY_EXPRESSION)
accept(MULTIPLICATIVE_EXPRESSION, MULTIPLICATIVE_EXPRESSION, T.ASTERISK, UNARY_EXPRESSION)
accept(MULTIPLICATIVE_EXPRESSION, MULTIPLICATIVE_EXPRESSION, T.DIVISION, UNARY_EXPRESSION)
accept(MULTIPLICATIVE_EXPRESSION, MULTIPLICATIVE_EXPRESSION, T.MODULO, UNARY_EXPRESSION)

accept(UNARY_EXPRESSION, PRE_INCREMENT_EXPRESSION)
accept(UNARY_EXPRESSION, PRE_DECREMENT_EXPRESSION)
accept(UNARY_EXPRESSION, T.PLUS, UNARY_EXPRESSION)
accept(UNARY_EXPRESSION, T.MINUS, UNARY_EXPRESSION)
accept(UNARY_EXPRESSION, UNARY_EXPRESSION_NOT_PLUS_MINUS)

accept(PRE_INCREMENT_EXPRESSION, T.INCREMENT, UNARY_EXPRESSION)

accept(PRE_DECREMENT_EXPRESSION, T.DECREMENT, UNARY_EXPRESSION)

accept(UNARY_EXPRESSION_NOT_PLUS_MINUS, POSTFIX_EXPRESSION)
accept(UNARY_EXPRESSION_NOT_PLUS_MINUS, T.BITWISE_NOT, UNARY_EXPRESSION)
accept(UNARY_EXPRESSION_NOT_PLUS_MINUS, T.LOGICAL_NEGATION, UNARY_EXPRESSION)
accept(UNARY_EXPRESSION_NOT_PLUS_MINUS, CAST_EXPRESSION)
accept(UNARY_EXPRESSION_NOT_PLUS_MINUS, SWITCH_EXPRESSION)

branch(POSTFIX_EXPRESSION)
PRIMARY,
EXPRESSION_NAME,
POST_INCREMENT_EXPRESSION,
POST_DECREMENT_EXPRESSION

accept(POST_INCREMENT_EXPRESSION, POSTFIX_EXPRESSION, T.INCREMENT)

accept(POST_DECREMENT_EXPRESSION, POSTFIX_EXPRESSION, T.DECREMENT)

accept(CAST_EXPRESSION, T.LEFT_ROUND_BRACKET, PRIMITIVE_TYPE, T.RIGHT_ROUND_BRACKET, UNARY_EXPRESSION)
accept(CAST_EXPRESSION, T.LEFT_ROUND_BRACKET, REFERENCE_TYPE, repeatOf(ADDITIONAL_BOUND), T.RIGHT_ROUND_BRACKET, UNARY_EXPRESSION_NOT_PLUS_MINUS)
accept(CAST_EXPRESSION, T.LEFT_ROUND_BRACKET, REFERENCE_TYPE, repeatOf(ADDITIONAL_BOUND), T.RIGHT_ROUND_BRACKET, LAMBDA_EXPRESSION)

accept(SWITCH_EXPRESSION, T.SWITCH, T.LEFT_ROUND_BRACKET, EXPRESSION, T.RIGHT_ROUND_BRACKET, SWITCH_BLOCK)

accept(CONSTANT_EXPRESSION, EXPRESSION)

}
