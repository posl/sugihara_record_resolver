package qouteall.imm_ptl.core.portal.animation;

import net.minecraft.nbt.CompoundTag;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.phys.Vec3;
import qouteall.q_misc_util.Helper;
import qouteall.q_misc_util.my_util.DQuaternion;

public class RotationAnimation implements PortalAnimationDriver {
    
    public static void init() {
        PortalAnimationDriver.registerDeserializer(
            new ResourceLocation("imm_ptl:rotation"),
            RotationAnimation::deserialize
        );
    }
    
    public final Vec3 initialPosition;
    public final DQuaternion initialOrientation;
    public final Vec3 rotationCenter;
    public final Vec3 rotationAxis;
    public final double degreesPerTick;
    public final long startGameTime;
    public final long endGameTime;
    
    public RotationAnimation(Vec3 initialPosition, DQuaternion initialOrientation, Vec3 rotationCenter, Vec3 rotationAxis, double degreesPerTick, long startGameTime, long endGameTime) {
        this.initialPosition = initialPosition;
        this.initialOrientation = initialOrientation;
        this.rotationCenter = rotationCenter;
        this.rotationAxis = rotationAxis;
        this.degreesPerTick = degreesPerTick;
        this.startGameTime = startGameTime;
        this.endGameTime = endGameTime;
    }
    
    @Override
    public CompoundTag toTag() {
        CompoundTag tag = new CompoundTag();
        
        tag.putString("type", "imm_ptl:rotation");
        Helper.putVec3d(tag, "initialPosition", initialPosition);
        tag.put("initialOrientation", initialOrientation.toTag());
        Helper.putVec3d(tag, "rotationCenter", rotationCenter);
        Helper.putVec3d(tag, "rotationAxis", rotationAxis);
        tag.putDouble("degreesPerTick", degreesPerTick);
        tag.putLong("startGameTime", startGameTime);
        tag.putLong("endGameTime", endGameTime);
        
        return tag;
    }
    
    private static RotationAnimation deserialize(CompoundTag tag) {
        Vec3 initialPosition = Helper.getVec3d(tag, "initialPosition");
        DQuaternion initialOrientation = DQuaternion.fromTag(tag.getCompound("initialOrientation"));
        Vec3 rotationCenter = Helper.getVec3d(tag, "rotationCenter");
        Vec3 rotationAxis = Helper.getVec3d(tag, "rotationAxis");
        double degreesPerTick = tag.getDouble("degreesPerTick");
        long startGameTime = tag.getLong("startGameTime");
        long endGameTime = tag.getLong("endGameTime");
        return new RotationAnimation(
            initialPosition, initialOrientation, rotationCenter, rotationAxis,
            degreesPerTick, startGameTime, endGameTime
        );
    }
    
    @Override
    public boolean update(
        UnilateralPortalState.Builder stateBuilder,
        long tickTime,
        float partialTicks
    ) {
        double passedTicks = ((double) (tickTime - 1 - startGameTime)) + partialTicks;
    
        boolean ended = false;
        if (passedTicks >= (endGameTime - startGameTime)) {
            ended = true;
            passedTicks = endGameTime - startGameTime;
        }
        
        double angle = degreesPerTick * passedTicks;
        DQuaternion rotation = DQuaternion.rotationByDegrees(rotationAxis, angle);
        stateBuilder.orientation(rotation.hamiltonProduct(initialOrientation));
        
        Vec3 offset = initialPosition.subtract(rotationCenter);
        Vec3 rotatedOffset = rotation.rotate(offset);
        stateBuilder.position(rotationCenter.add(rotatedOffset));
        
        return ended;
    }
    
    @Override
    public void obtainEndingState(UnilateralPortalState.Builder stateBuilder, long tickTime) {
        if (endGameTime == Long.MAX_VALUE) {
            // infinite animation, keep the current state when stopping
            return;
        }
        
        update(stateBuilder, endGameTime, 0);
    }
    
    // generated by GitHub Copilot
    public static class Builder {
        public Vec3 initialPosition;
        public DQuaternion initialOrientation;
        public Vec3 rotationCenter;
        public Vec3 rotationAxis;
        public double degreesPerTick;
        public long startGameTime;
        public long endGameTime;
        
        public RotationAnimation build() {
            return new RotationAnimation(
                initialPosition, initialOrientation, rotationCenter, rotationAxis,
                degreesPerTick, startGameTime, endGameTime
            );
        }
        
        public Builder setInitialPosition(Vec3 initialPosition) {
            this.initialPosition = initialPosition;
            return this;
        }
        
        public Builder setInitialOrientation(DQuaternion initialOrientation) {
            this.initialOrientation = initialOrientation;
            return this;
        }
        
        public Builder setRotationCenter(Vec3 rotationCenter) {
            this.rotationCenter = rotationCenter;
            return this;
        }
        
        public Builder setRotationAxis(Vec3 rotationAxis) {
            this.rotationAxis = rotationAxis;
            return this;
        }
        
        public Builder setDegreesPerTick(double degreesPerTick) {
            this.degreesPerTick = degreesPerTick;
            return this;
        }
        
        public Builder setStartGameTime(long startGameTime) {
            this.startGameTime = startGameTime;
            return this;
        }
        
        public Builder setEndGameTime(long endGameTime) {
            this.endGameTime = endGameTime;
            return this;
        }
        
    }
    
}
