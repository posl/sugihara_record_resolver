package qouteall.imm_ptl.core.portal.animation;

import net.minecraft.nbt.CompoundTag;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.util.Mth;
import net.minecraft.world.phys.Vec3;
import qouteall.imm_ptl.core.portal.Portal;
import qouteall.q_misc_util.Helper;
import qouteall.q_misc_util.my_util.DQuaternion;
import qouteall.q_misc_util.my_util.Vec2d;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class NormalAnimation implements PortalAnimationDriver {
    public static void init() {
        PortalAnimationDriver.registerDeserializer(
            new ResourceLocation("imm_ptl:normal"),
            NormalAnimation::deserialize
        );
    }
    
    public static class Phase {
        public long durationTicks;
        @Nullable
        public Vec3 offset;
        @Nullable
        public DQuaternion rotation;
        @Nullable
        public Vec2d sizeScaling;
        public TimingFunction timingFunction;
        
        public Phase(
            long durationTicks,
            @Nullable Vec3 offset,
            @Nullable DQuaternion rotation,
            @Nullable Vec2d sizeScaling,
            TimingFunction timingFunction
        ) {
            this.durationTicks = durationTicks;
            this.offset = offset;
            this.rotation = rotation;
            this.sizeScaling = sizeScaling;
            this.timingFunction = timingFunction;
        }
        
        private void transformIntermediary(UnilateralPortalState.Builder currentState, double phaseProgress) {
            if (this.offset != null) {
                currentState.offset(this.offset.scale(phaseProgress));
            }
            if (this.rotation != null) {
                currentState.rotate(
                    DQuaternion.interpolate(
                        DQuaternion.identity,
                        this.rotation,
                        phaseProgress
                    )
                );
            }
            if (this.sizeScaling != null) {
                currentState.scaleWidth(Mth.lerp(1, currentState.width, this.sizeScaling.x()));
                currentState.scaleHeight(Mth.lerp(1, currentState.height, this.sizeScaling.y()));
            }
        }
        
        public void transformFull(UnilateralPortalState.Builder currentState) {
            if (this.offset != null) {
                currentState.offset(this.offset);
            }
            if (this.rotation != null) {
                currentState.rotate(this.rotation);
            }
            if (this.sizeScaling != null) {
                currentState.scaleWidth(this.sizeScaling.x());
                currentState.scaleHeight(this.sizeScaling.y());
            }
        }
        
        public CompoundTag toTag() {
            CompoundTag tag = new CompoundTag();
            tag.putLong("durationTicks", durationTicks);
            if (offset != null) {
                Helper.putVec3d(tag, "offset", offset);
            }
            if (rotation != null) {
                tag.put("rotation", rotation.toTag());
            }
            if (sizeScaling != null) {
                tag.putDouble("widthScaling", sizeScaling.x());
                tag.putDouble("heightScaling", sizeScaling.y());
            }
            tag.putString("timingFunction", timingFunction.toString());
            return tag;
        }
        
        
        public static Phase fromTag(CompoundTag compoundTag) {
            long durationTicks = compoundTag.getLong("durationTicks");
            Vec3 offset = Helper.getVec3dOptional(compoundTag, "offset");
            DQuaternion rotation =
                compoundTag.contains("rotation") ?
                    DQuaternion.fromTag(compoundTag.getCompound("rotation")) : null;
            Vec2d sizeScaling = compoundTag.contains("widthScaling") ? new Vec2d(
                compoundTag.getDouble("widthScaling"),
                compoundTag.getDouble("heightScaling")
            ) : null;
            TimingFunction timingFunction =
                compoundTag.contains("timingFunction") ?
                    TimingFunction.fromString(compoundTag.getString("timingFunction")) :
                    TimingFunction.linear;
            
            return new Phase(
                durationTicks,
                offset,
                rotation,
                sizeScaling,
                timingFunction
            );
        }
        
        public Phase getFlippedVersion() {
            return new Phase(
                durationTicks,
                offset,
                rotation == null ? null : rotation.hamiltonProduct(UnilateralPortalState.flipAxisH),
                sizeScaling,
                timingFunction
            );
        }
        
        // generated by GitHub Copilot
        public static class Builder {
            // duration can be zero
            private long durationTicks;
            private Vec3 offset;
            private DQuaternion rotation;
            private Vec2d sizeScaling;
            private TimingFunction timingFunction = TimingFunction.linear;
            
            public Builder() {
            }
            
            public Builder durationTicks(long durationTicks) {
                this.durationTicks = durationTicks;
                return this;
            }
            
            public Builder offset(Vec3 position) {
                this.offset = position;
                return this;
            }
            
            public Builder rotation(DQuaternion orientation) {
                this.rotation = orientation;
                return this;
            }
            
            public Builder sizeScaling(Vec2d size) {
                this.sizeScaling = size;
                return this;
            }
            
            public Builder timingFunction(TimingFunction timingFunction) {
                this.timingFunction = timingFunction;
                return this;
            }
            
            public Phase build() {
                return new Phase(durationTicks, offset, rotation, sizeScaling, timingFunction);
            }
        }
    }
    
    public final List<Phase> phases;
    public final long startingGameTime;
    public final int loopCount;
    
    private final long ticksPerRound;
    
    public NormalAnimation(
        List<Phase> phases,
        long startingGameTime,
        int loopCount
    ) {
        this.phases = phases;
        this.startingGameTime = startingGameTime;
        this.loopCount = loopCount;
        
        long totalTicks = 0;
        for (Phase phase : phases) {
            totalTicks += phase.durationTicks;
        }
        ticksPerRound = totalTicks;
    }
    
    private static NormalAnimation deserialize(CompoundTag compoundTag) {
        UnilateralPortalState initialState = UnilateralPortalState.fromTag(compoundTag.getCompound("initialState"));
        
        List<Phase> phases = Helper.listTagToList(
            Helper.getCompoundList(compoundTag, "phases"),
            Phase::fromTag
        );
        
        long startingGameTime = compoundTag.getLong("startingGameTime");
        
        int loopCount = compoundTag.getInt("loopCount");
        
        if (phases.isEmpty() || loopCount < 0) {
            throw new RuntimeException("invalid NormalAnimation");
        }
        
        return new NormalAnimation(
            phases,
            startingGameTime,
            loopCount
        );
    }
    
    @Override
    public CompoundTag toTag() {
        CompoundTag tag = new CompoundTag();
        
        tag.putString("type", "imm_ptl:normal");
        tag.put("phases", Helper.listToListTag(phases, Phase::toTag));
        tag.putLong("startingGameTime", startingGameTime);
        tag.putInt("loopCount", loopCount);
        
        return tag;
    }
    
    private long getTotalDuration() {
        if (loopCount > 100000) {
            return Long.MAX_VALUE;
        }
        
        return ticksPerRound * loopCount;
    }
    
    @Override
    public boolean update(
        UnilateralPortalState.Builder stateBuilder,
        long tickTime,
        float partialTicks
    ) {
        if (ticksPerRound == 0 || phases.isEmpty()) {
            Helper.err("Invalid NormalAnimation");
            return true;
        }
        
        double passedTicks = ((double) (tickTime - 1 - startingGameTime)) + partialTicks;
        long totalDuration = getTotalDuration();
        
        boolean ends = false;
        if (passedTicks >= totalDuration - 1) {
            passedTicks = totalDuration - 1;
            ends = true;
        }
        
        if (passedTicks < -1) {
            Helper.err("NormalAnimation starts in the future");
            return true;
        }
        
        // modulo works for double!
        double passedTicksInThisRound = passedTicks % ((double) ticksPerRound);
        long roundIndex = Math.floorDiv((long) passedTicks, ticksPerRound);
        
        long traversedTicks = 0;
        for (Phase phase : phases) {
            if (phase.durationTicks != 0 && passedTicksInThisRound < traversedTicks + phase.durationTicks) {
                double phaseProgress = (1 + passedTicksInThisRound - traversedTicks) / (double) phase.durationTicks;
                phaseProgress = phase.timingFunction.mapProgress(phaseProgress);
                
                phase.transformIntermediary(stateBuilder, phaseProgress);
                break;
            }
            else {
                phase.transformFull(stateBuilder);
                traversedTicks += phase.durationTicks;
            }
        }
        
        return ends;
    }
    
    @Override
    public void obtainEndingState(UnilateralPortalState.Builder stateBuilder, long tickTime) {
        end(stateBuilder);
    }
    
    @Override
    public PortalAnimationDriver getFlippedVersion() {
        return new NormalAnimation(
            phases.stream().map(phase -> phase.getFlippedVersion()).collect(Collectors.toList()),
            startingGameTime,
            loopCount
        );
    }
    
    private void end(UnilateralPortalState.Builder stateBuilder) {
        for (Phase phase : phases) {
            phase.transformFull(stateBuilder);
        }
    }
    
    // generated by GitHub Copilot
    public static class Builder {
        private List<Phase> phases = new ArrayList<>();
        private long startingGameTime;
        private int loopCount;
        
        public Builder() {
        }
        
        public Builder phases(List<Phase> phases) {
            this.phases = phases;
            return this;
        }
        
        public Builder startingGameTime(long startingGameTime) {
            this.startingGameTime = startingGameTime;
            return this;
        }
        
        public Builder loopCount(int loopCount) {
            this.loopCount = loopCount;
            return this;
        }
        
        public NormalAnimation build() {
            return new NormalAnimation(phases, startingGameTime, loopCount);
        }
    }
    
    public static NormalAnimation createSizeAnimation(
        Portal portal, Vec2d startSizeScale, Vec2d toSizeScale,
        long startingGameTime, long durationTicks,
        TimingFunction timingFunction
    ) {
        Phase initialPhase = new Phase.Builder()
            .durationTicks(0)
            .sizeScaling(startSizeScale)
            .timingFunction(timingFunction)
            .build();
        
        Phase endingPhase = new Phase.Builder()
            .durationTicks(durationTicks)
            .sizeScaling(toSizeScale)
            .timingFunction(timingFunction)
            .build();
        
        return new Builder()
            .phases(List.of(endingPhase))
            .startingGameTime(startingGameTime)
            .loopCount(1)
            .build();
    }
}
