package qouteall.imm_ptl.core.portal.animation;

import net.minecraft.nbt.CompoundTag;
import net.minecraft.resources.ResourceLocation;
import qouteall.imm_ptl.core.portal.Portal;
import qouteall.imm_ptl.core.portal.PortalState;
import qouteall.q_misc_util.Helper;

import javax.annotation.Nullable;
import java.util.List;

public class NormalAnimation implements PortalAnimationDriver {
    public static void init() {
        PortalAnimationDriver.registerDeserializer(
            new ResourceLocation("imm_ptl:normal"),
            NormalAnimation::deserialize
        );
    }
    
    public static class Phase {
        public long durationTicks;
        public UnilateralPortalState targetState;
        public TimingFunction timingFunction;
        
        public static Phase fromTag(CompoundTag compoundTag) {
            Phase phase = new Phase();
            phase.durationTicks = compoundTag.getLong("durationTicks");
            phase.targetState = UnilateralPortalState.fromTag(compoundTag.getCompound("targetState"));
            phase.timingFunction = TimingFunction.fromString(compoundTag.getString("timingFunction"));
            return phase;
        }
        
        public CompoundTag toTag() {
            CompoundTag tag = new CompoundTag();
            tag.putLong("durationTicks", durationTicks);
            tag.put("targetState", targetState.toTag());
            tag.putString("timingFunction", timingFunction.toString());
            return tag;
        }
        
        // generated by GitHub Copilot
        public static class Builder {
            public long durationTicks;
            public UnilateralPortalState targetState;
            public TimingFunction timingFunction;
            
            public Builder durationTicks(long durationTicks) {
                this.durationTicks = durationTicks;
                return this;
            }
            
            public Builder targetState(UnilateralPortalState targetState) {
                this.targetState = targetState;
                return this;
            }
            
            public Builder timingFunction(TimingFunction timingFunction) {
                this.timingFunction = timingFunction;
                return this;
            }
            
            public Phase build() {
                Phase phase = new Phase();
                phase.durationTicks = durationTicks;
                phase.targetState = targetState;
                phase.timingFunction = timingFunction;
                return phase;
            }
        }
    }
    
    public UnilateralPortalState initialState;
    public List<Phase> phases;
    public long startingGameTime;
    public int loopCount;
    
    // cache field, not serialized
    @Nullable
    private Long ticksPerRound;
    
    private static NormalAnimation deserialize(CompoundTag compoundTag) {
        NormalAnimation animation = new NormalAnimation();
        animation.initialState = UnilateralPortalState.fromTag(compoundTag.getCompound("initialState"));
        animation.phases = Helper.listTagToList(
            Helper.getCompoundList(compoundTag, "phases"),
            Phase::fromTag
        );
        animation.startingGameTime = compoundTag.getLong("startingGameTime");
        animation.loopCount = compoundTag.getInt("loopCount");
        
        if (animation.phases.isEmpty() || animation.loopCount < 0) {
            throw new RuntimeException("invalid NormalAnimation");
        }
        
        return animation;
    }
    
    @Override
    public CompoundTag toTag() {
        CompoundTag tag = new CompoundTag();
        
        tag.putString("type", "imm_ptl:normal");
        tag.put("initialState", initialState.toTag());
        tag.put("phases", Helper.listToListTag(phases, Phase::toTag));
        tag.putLong("startingGameTime", startingGameTime);
        tag.putInt("loopCount", loopCount);
        
        return tag;
    }
    
    private long getTicksPerRound() {
        if (ticksPerRound == null) {
            ticksPerRound = phases.stream().mapToLong(p -> p.durationTicks).sum();
        }
        return ticksPerRound;
    }
    
    private long getTotalDuration() {
        if (loopCount > 10000) {
            return Long.MAX_VALUE;
        }
        
        return getTicksPerRound() * loopCount;
    }
    
    @Override
    public boolean update(
        UnilateralPortalState.Builder stateBuilder,
        long tickTime,
        float partialTicks
    ) {
        double passedTicks = ((double) (tickTime - 1 - startingGameTime)) + partialTicks;
        long totalDuration = getTotalDuration();
        
        boolean ends = false;
        if (passedTicks >= totalDuration) {
            stateBuilder.from(getEndingState());
            return true;
        }
        
        // modulo works for double!
        double passedTicksInRound = passedTicks % ((double) getTicksPerRound());
        
        long traversedTicks = 0;
        UnilateralPortalState phaseStartingState = initialState;
        for (Phase phase : phases) {
            if (passedTicksInRound <= traversedTicks + phase.durationTicks) {
                double phaseProgress = (passedTicksInRound - traversedTicks) / (double) phase.durationTicks;
                phaseProgress = phase.timingFunction.mapProgress(phaseProgress);
                UnilateralPortalState currentState = UnilateralPortalState.interpolate(
                    phaseStartingState, phase.targetState, phaseProgress
                );
                stateBuilder.from(currentState);
                break;
            }
            traversedTicks += phase.durationTicks;
            phaseStartingState = phase.targetState;
        }
        
        return false;
    }
    
    private UnilateralPortalState getEndingState() {
        Phase lastPhase = phases.get(phases.size() - 1);
        return lastPhase.targetState;
    }
    
    @Override
    public void serverSideForceStop(UnilateralPortalState.Builder stateBuilder, long tickTime) {
        stateBuilder.from(getEndingState());
    }
    
    public static NormalAnimation createOnePhaseAnimation(
        UnilateralPortalState fromState, UnilateralPortalState toState,
        long startingGameTime, long durationTicks,
        TimingFunction timingFunction
    ) {
        NormalAnimation animation = new NormalAnimation();
        animation.initialState = fromState;
        
        Phase phase = new Phase();
        phase.durationTicks = durationTicks;
        phase.targetState = toState;
        phase.timingFunction = timingFunction;
        animation.phases = List.of(phase);
        
        animation.startingGameTime = startingGameTime;
        animation.loopCount = 1;
        
        return animation;
    }
}
